name: Snyk (Extra task)

on:
  pull_request:
    branches: [ "main", "master" ]
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write

jobs:
  snyk-scan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Snyk CLI
        run: npm install -g snyk

      - name: Authenticate Snyk
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: snyk auth "$SNYK_TOKEN"

      - name: Run Snyk Open Source test (JSON report)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: snyk test --json-file-output=snyk-os.json || true

      - name: Ensure report exists
        run: '[ -f snyk-os.json ] || echo "{}" > snyk-os.json'

      - name: Comment PR with Snyk vulnerabilities (bash)
        if: ${{ github.event_name == 'pull_request' }}
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          API_URL: ${{ github.api_url }}
        run: |
          set -euo pipefail
          json="snyk-os.json"

          [ -s "$json" ] || { echo "snyk-os.json missing/empty"; exit 0; }

          # Повертає ПЕРШУ (за пріоритетом: critical > high > medium) вразливість з vulnerabilities[] або remediation.unresolved[]
          pick_first_vuln() {
            jq -r '
              def sevnorm: ( .severityWithCritical // .severity // "unknown" ) | ascii_downcase;
              def weight:
                if sevnorm=="critical" then 3
                elif sevnorm=="high" then 2
                elif sevnorm=="medium" then 1
                else 0 end;
              def mk_url: ( .url // ( "https://security.snyk.io/vuln/" + ( .id // "" ) ) );
              def mk_pkg: ( .packageName // .moduleName // .name // "unknown" );
              def mk_ver: ( .version // "unknown" );

              # звести дві колекції до спільної схеми
              ( .vulnerabilities // [] ) as $v1
              | ( .remediation.unresolved // [] ) as $v2
              | ( $v1 + $v2 )
              | map({
                  id: (.id // ""),
                  title: (.title // "Unknown issue"),
                  severity: ( .severityWithCritical // .severity // "unknown" ),
                  _sev: (sevnorm),
                  _w: weight,
                  url: mk_url,
                  pkg: mk_pkg,
                  ver: mk_ver,
                  from: (.from // [])
                })
              | map(select(._w > 0))                          # залишаємо critical/high/medium
              | sort_by(-._w)                                  # пріоритет: critical > high > medium
              | first                                          # беремо першу
              | if . == null then empty else . end
            ' "$json"
          }

          VULN_JSON="$(pick_first_vuln || true)"

          if [ -z "$VULN_JSON" ]; then
            echo "No critical/high/medium vulnerabilities found."
            exit 0
          fi

          # Витягаємо поля
          title="$(jq -r '.title' <<<"$VULN_JSON")"
          sev_lc="$(jq -r '._sev' <<<"$VULN_JSON")"
          # Робимо формат з великої літери ("medium" -> "Medium")
          sev_cap="$(tr '[:lower:]' '[:upper:]' <<<"${sev_lc:0:1}")${sev_lc:1}"
          url="$(jq -r '.url' <<<"$VULN_JSON")"
          pkg="$(jq -r '.pkg' <<<"$VULN_JSON")"
          ver="$(jq -r '.ver' <<<"$VULN_JSON")"

          # Спробуємо знайти в .from елемент саме для цього пакета; інакше fallback "pkg@ver"
          intro="$(jq -r --arg pkg "$pkg" '
            (.from // []) | map(select(test("^" + $pkg + "@"))) | last // empty
          ' <<<"$VULN_JSON")"
          [ -n "$intro" ] || intro="${pkg}@${ver}"

          BODY=$'We detected vulnerability in snyk scanning :\n'"✗ ${title} [${sev_cap} Severity][${url}] in ${pkg}@${ver}\n    introduced by ${intro}"

          PR_NUMBER="$(jq -r '.pull_request.number' "$GITHUB_EVENT_PATH")"
          COMMENTS_URL="${API_URL}/repos/${REPO}/issues/${PR_NUMBER}/comments"
          BODY_JSON=$(jq -Rn --arg b "$BODY" '{body: $b}')

          curl -sS -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            --data "${BODY_JSON}" \
            "${COMMENTS_URL}" >/dev/null

          echo "Comment posted to PR #${PR_NUMBER}."

     
       
       
